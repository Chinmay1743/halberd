\documentclass[a4paper]{book}
\usepackage[english]{babel}
\begin{document}

\title{Halberd user's guide}
\author{Juan M. Bello Rivas}
\maketitle

\tableofcontents

% 1. Explain the problem being solved.
% 2. Present the concepts, not just the features.
% 3. Give'em more than they deserve.
% 4. Make it enjoyable to read.

\chapter{Introduction}

halberd discovers HTTP load balancers. It is useful for testing load balancer
configurations and for web application auditing purposes. 

\section{Motivation}

To cope with heavy traffic loads, web site administrators often install load
balancer devices. These machines hide (possibly) many real web servers behind
a virtual IP. They receive HTTP requests and redirect them to the real web
servers in order to share the traffic between them.

There are a few ways to map the servers behind the VIP and to reach them
individually.

Identifying and being able to reach all real servers individually (effectively
bypassing the load balancer) is very important for an attacker trying to break
into a site because it is often the case that there are configuration
differences ranging from slight:

\begin{itemize}
  \item server software versions,
  \item server modules
\end{itemize}

to the extreme:

\begin{itemize}
  \item different platforms
  \item server software.
\end{itemize}

For an attacker this information is crucial because he might find vulnerable
configurations that otherwise (without mapping the real servers) could have
gone unnoticed.

But someone trying to break into a website doesn't have server software as its
only target. He will try to subvert dynamic server pages in several ways.  By
identifying all the real servers and scanning them individually for
vulnerabilities he might find bugs affecting only one or a few of the web
servers. Even if all machines are running the same server software halberd can
detect them and this can lead to more through vulnerability scans on the
application level.

\chapter{Concepts}

halberd sends multiple requests to the target webserver and analyzes the
replies looking for signs of load balancing.

The following is a list of detection techniques currently implemented:

\section{Clock comparison}

HTTP responses reveal the internal clock of the machine serving them. By
tracking how many different clocks appear we can have some insight into the
number of real servers.

\section{MIME header field names, values and their order}

Differences in fields appearing in server responses can allow halberd to
narrow down its search.

\section{Special cookie usage}

Some HTTP load balancers generate a cookie which will be used to direct future
requests to a certain server. Administrators can also set up cookies that will
be taken into account for deciding where to send requests. By selecting which
cookies to send, the program attempts to force the load balancer to route
requests to a server of our choice.

\section{Generating high amounts of traffic}

In certain configurations only a few web servers will deal with website
traffic. When it reaches a threshold the load balancer will start directing
requests to the rest of the web servers which were waiting for this event to
happen.

halberd can be used in a distributed fashion to generate heavy traffic loads.
Running the program in RPC server mode in computers located at several
networks lets the user launch distributed scans against a web site, forcing
the idle web servers to reveal themselves.

\section{Using different URLs}

An HTTP load balancer can be configured to take URLs into account when
deciding where to direct the requests. Gathering URLs with a spider and
feeding them into halberd will make it more likely that all servers will reply
at some point.

\section{Getting around server-side caches}

We can come across to websites having server-side caches. These configurations
are appropriately identified and in case there is more than one cache, halberd
can enumerate how many there are. This is mostly an informative feature.

\section{Obtaining public IP addresses}

Sometimes cookies or special MIME fields can reveal IP addresses or host
names. In some cases these can be reached directly from the Internet with no
more hassle to direct requests to each of them individually.

\chapter{Installation}

\section{Prerequisites}

You need Python version 2.4 or above and the threading and MD5 (or SHA1)
modules should be enabled.  If you want to scan through HTTPS you will also
need a Python interpreter configured with support for SSL sockets.

\section{Supported platforms}

halberd should work in every machine satisfying the prerequisites mentioned
above.  The program has been successfully built and tested on Linux, Windows
2000 and Mac OS X.

\section{Installation steps}

Installing halberd is a very simple task.  It suffices to write:

\begin{verbatim}
# python setup.py install
\end{verbatim}

Once you execute halberd for the first time it writes the file
\verb|$HOME/.halberd/halberd.cfg|. This file lets the user configure a proxy
and specify an SSL certificate.

\chapter{Operation}

This chapter explains how to use halberd in the real world.

\section{Sample session}

Peter is on the phone, talking to a client who asks him to perform a
penetration test of a large web application that's just entered production.

He impatiently taps his fingers against the wooden table waiting for the email
containing the details of his job to arrive.  It finally hits his mailbox and
our hero begins his dutiful work.

First of all, a load balancer scanning is due.  He opens up a virtual terminal
and writes:

\begin{verbatim}
$ halberd http://www.target-company.com
\end{verbatim}

Peter reads the output of his previous incantation and nods...

\begin{verbatim}
halberd 1.0.0

INFO looking up host www.target-company.com...
INFO host lookup done.
INFO www.target-company.com resolves to x.x.x.1
INFO www.target-company.com resolves to x.x.x.2
x.x.x.1   [######    ]  clues:   3 | replies:  23 | missed:   0
\end{verbatim}

After 23 replies he thinks halberd has enough samples to analyze, so he hits
CONTROL-C and stops the scan for this host.  Peter notes there is DNS load
balancing in place so he'll have to check both IP addresses.

\begin{verbatim}

*** finished (received SIGINT) ***

=============================================================
http://www.target-company.com (x.x.x.1): 1 real server(s)
=============================================================

server 1: foo/1.2.3  mod_bar/4.2 (Unix)
-------------------------------------------------------------

difference: 3600 seconds
successful requests: 23 hits (100.00%)
header fingerprint: c0ba8262100168851872c8feea3196f21ba2d732
different headers:
  1. Server: foo/1.2.3  mod_bar/4.2 (Unix)
\end{verbatim}

"Nothing to see here, let's move along" muttered Peter while halberd
progressed to the second IP address.

\begin{verbatim}
============================================================
http://www.target-company.com (x.x.x.2): 2 real server(s)
============================================================

server 1: foo/1.2.2  mod_bar/4.2 (Unix)
------------------------------------------------------------

difference: 3600 seconds
successful requests: 11 hits (33.33%)
header fingerprint: 732deadbeef100168851872c8feea196f21ba2d2
different headers:
  1. Date: Wed, 16 Aug 2006 22:47:04 GMT
  2. Server: foo/1.2.2  mod_bar/4.2 (Unix)

server 2: foo/1.2.3  mod_bar/4.2 (Unix)
------------------------------------------------------------

difference: 3662 seconds
successful requests: 23 hits (66.66%)
header fingerprint: ad2d33a88f259b434c094a7b1172f5697a35cff4
different headers:
  1. Date: Wed, 16 Aug 2006 22:46:02 GMT
  2. Server: foo/1.2.3  mod_bar/4.2 (Unix)
\end{verbatim}

"Aha!" shouts our fellow, almost falling off his chair.  "Not only did they
forget to set up NTP on those servers, letting me distinguish them easily,
they also have different \emph{server versions}!"

His eyes go blank while he runs a search in his brain cell based vulnerability
database for the terms foo/1.2.2 mod\_bar/4.2.  He recalls there was a recent
exploit for a buffer overflow in that version of foo.

Peter has to take into account that the vulnerable web server gets one third
of the traffic (33.33\%).  He executes the exploit enough times to make sure
it hits the exposed target and finally he breaks into the machine.

"I'm so lucky to have this wonderful load balancer detector in my toolkit!
This vulnerability could have gone easily unnoticed."

Our hero begins to walk in circles around the room, planning the next stages
of his assault and anticipating with apprehension the time when he'll have to
write the report for his client.

\section{Command line options}

\subsection{--version}

Shows program's version number and exits.

\subsection{-h, --help}

Shows a help message describing every option and exits.

\subsection{-q, --quiet}

Runs quietly, limiting the amount of information being displayed while the
program runs.

\subsection{-d, --debug}

Enables debugging information.  This can be useful if you want halberd to dump
all the HTTP headers or if you're debugging the tool itself.

\subsection{-t NUM, --time=NUM}

Stops halberd after NUM seconds have passed since the beginning of the
scanning phase.

\subsection{-p NUM, --parallelism=NUM}

Specifies the number of parallel threads to use for scanning.  This can
increase the amount of requests per second during the scanning phase.

\subsection{-u FILE, --urlfile=FILE}

Read URLs from FILE.  FILE is a text archive containing an URL in each line.
halberd will scan these URLs one by one.

\subsection{-o FILE, --out=FILE}

Writes the human-readable results from the analysis to FILE.

\subsection{-a ADDR, --address=ADDR}

Specifies the target by its IP addres.

\subsection{-r FILE, --read=FILE}

Loads and analyzes clues from FILE.  Clues are what halberd uses to figure out
(during the analysis phase) whether there is a load balancer or not.  These
clues can be written (un-analyzed) to a file with the --write option for
comparison with future scans, etc.

\subsection{-w DIR, --write=DIR}

Saves clues to the specified directory.  If it doesn't exist, it will be
created.

\subsection{--config=FILE}

Tells halberd to the configuration stored in FILE instead of the default
\verb|halberd.cfg|.

\chapter{Support}

Suggestions, bug reports and patches can be emailed to the author at
\verb|jmbr+halberd at superadditive dot com|

\end{document}

% vim: ts=2 sw=2 et ft=tex
