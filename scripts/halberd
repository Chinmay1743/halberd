#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Copyright (C) 2004 Juan M. Bello Rivas <rwx@synnergy.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


"""Command line interface and main driving module.

@var default_scantime: Time to spend probing the target expressed in seconds.
@var default_parallelism: Number of parallel threads to launch for the scan.
@var default_conf_file: Name of the default configuration file for halberd.
"""

__revision__ = '$Id: halberd,v 1.12 2004/02/15 17:01:46 rwx Exp $'


import sys
import time

import hlbd.version as version
import hlbd.clues.analysis as analysis


default_scantime = 30

default_parallelism = 4

default_conf_file = 'halberd.cfg'


class Halberd:
    """HTTP load balancer detector.
    """

    url = None
    addr = None

    rpc_servers = None
    rpc_serv_addr = None

    proxy_serv_addr = None

    clues = []
    analyzed = []

    parallelism = default_parallelism

    def __init__(self, verbose=False):
        self.verbose = verbose


    def setURL(self, url):
        """Ensures the URL is a valid one.
        """
        if url.startswith('http://') or url.startswith('https://'):
            self.url = url
        else:
            self.url = 'http://' + url

        return self

    def setAddr(self, addr):
        """Extract an IP address to scan.
        """
        import urlparse
        import socket

        netloc = urlparse.urlparse(self.url)[1]
        hostname = netloc.split(':')[0]

        self.info('looking up host %s... ' % hostname)

        try:
            name, aliases, addresses = socket.gethostbyname_ex(hostname)
        except socket.error, msg:
            self.fatal('%s (%s)\n' % (msg[1], hostname))

        self.info('done.\n\n')

        if addr:
            if addr not in addresses:
                self.fatal('%s resolves to a different address than %s\n'
                           % (hostname, addr))
            self.addr = addr  # Address found in the valid address list.
        else:
            # Pick up a valid address from the given list.
            if len(addresses) > 1:
                sys.stdout.write('warning: %s resolves to:\n'
                                 % hostname)
                sys.stdout.write('  %s <-- using this one.\n' % addresses[0])
                for a in addresses[1:]:
                    sys.stdout.write('  %s\n' % a)

            self.addr = addresses[0]


    def info(self, msg):
        """Display information to the user.
        """
        if self.verbose:
            sys.stdout.write(str(msg))
            sys.stdout.flush()

    def fatal(self, msg):
        """Fatal error notification.
        """
        sys.stderr.write(str(msg))
        sys.stderr.flush()
        sys.exit(-1)


    def load(self, filename):
        self.clues = analysis.load_clues(filename)

    def save(self, filename):
        analysis.save_clues(filename, self.clues)


    def setScantime(self, scantime=default_scantime):
        self.scantime = scantime
        return self

    def scan(self):
        import hlbd.scanlib as scanlib

        self.clues += scanlib.scan(self.addr, self.url, self.scantime,
                                  self.parallelism, self.verbose)
    def analyze(self):
        """Analyze clues.
        """
        self.analyzed = analysis.analyze(self.clues)

    def report(self, outfile):
        """Write a report.
        """
        import hlbd.reportlib

        hlbd.reportlib.report(self.addr, self.analyzed, outfile)


    def server(self):
        """Launch the program as a server.
        """
        import hlbd.rpclib

        hlbd.rpclib.server(self.rpc_serv_addr, self.verbose)

    def client(self):
        """Launch the program as a client.
        """
        def run_thr(addr, port, clues, lock):
            rpclib.client((addr, port), self.addr, self.url, self.scantime,
                          self.parallelism, self.verbose, (clues, lock))

        def normalize_clues(clues, delta):
            for clue in clues:
                clue._local -= delta
                clue._calcDiff()
            return clues

        import threading
        import hlbd.rpclib as rpclib

        assert self.rpc_servers is not None

        threads = []
        results = []
        lock = threading.Lock()

        thread = (threading.Thread(None, self.scan, None, ()))
        thread.start()
        threads.append(thread)

        for rpc_server in self.rpc_servers:
            addr, port = rpc_server.split(':')
            port = int(port)

            self.info('scanning through %s:%d\n' % (addr, port))

            thread = threading.Thread(None, run_thr, None, \
                                            (addr, port, results, lock))
            thread.start()
            threads.append(thread)

        self.info('\n')

        for thread in threads:
            thread.join()

#        for local, remote, clues in results:
        for result in results:
            if len(result) == 3:
                # Clues coming from a distributed scan.
                local, remote, clues = result
                self.clues.extend(normalize_clues(clues, remote - local))
            else:
                # Clues acquired locally.
                self.clues.extend(result)


    def readConf(self, cfgfile):
        """Read configuration file.
        """
        import hlbd.conflib as conflib

        reader = conflib.ConfReader()

        try:
            reader.open(cfgfile)
        except (IOError, conflib.InvalidConfFile):
            self.fatal('Couldn\'t open configuration file %s\n' % cfgfile)

        options = reader.parse()
        self.proxy_serv_addr = options.proxy_serv_addr

        self.rpc_serv_addr = options.rpc_serv_addr
        self.rpc_servers = options.rpc_servers

        reader.close()


def make_parser():
    """Sets up the command line option parser.
    """
    import optparse

    parser = optparse.OptionParser(usage='%prog [options] url',
                                   version=version.version.v_gnu)
    parser.add_option('-t', '--time',
                      action='store', type='int', dest='scantime',
                      help='time (in seconds) to spend analyzing the target',
                      metavar='NUM', default=default_scantime)

    parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
                      help='explain what is being done', default=False)

    parser.add_option('-o', '--out', action='store', dest='output',
                      help='write output to the specified file',
                      metavar='FILE', default='')

    parser.add_option('-a', '--addr', action='store', dest='addr',
                      help='specify address to scan',
                      metavar='ADDR', default='')

    parser.add_option('-w', '--write', action='store', dest='savefile',
                      help='saves clues to the specified file',
                      metavar='FILE', default='')
    parser.add_option('-r', '--read', action='store', dest='cluefile',
                      help='loads clues from the specified file',
                      metavar='FILE', default='')

    parser.add_option('-s', '--server', action='store_true', dest='rpc_server',
                      help='run as scan server')
    parser.add_option('-c', '--client', action='store_true', dest='rpc_client',
                      help='run as scan cilent')

    parser.add_option('-p', '--parallelism', action='store', type='int',
                      dest='parallelism', help='specifies the degree of parallelism',
                      metavar='NUM', default=default_parallelism)

    parser.add_option('-f', '--config', action='store', dest='confname',
                      help='use configuration file', metavar='FILE',
                      default=default_conf_file)

    return parser


def main(argv):
    """http load balancer detector's main routine.
    """
    parser = make_parser()

    (opts, args) = parser.parse_args(argv)

    halberd = Halberd(opts.verbose)

    halberd.info('%s\nhttp load balancer detector\n\n' % version.version.v_gnu)

    halberd.readConf(opts.confname)

    if opts.cluefile:
        # Load from file
        halberd.load(opts.cluefile)
        halberd.analyze()
        halberd.report(opts.output)
        sys.exit(0)
    elif opts.rpc_server:
        halberd.server()
        sys.exit(0)

    # Scan target.
    if len(args) < 1:
        # We need an URL to scan.
        parser.error('incorrect number of arguments')

    halberd.setURL(args[0]).setAddr(opts.addr)
    halberd.setScantime(opts.scantime)
    halberd.parallelism = opts.parallelism

    if opts.rpc_client:
        halberd.client()
    else:
        halberd.scan()

    if not halberd.clues:
        sys.exit(-1)

    if opts.savefile:
        halberd.save(opts.savefile)

    halberd.analyze()
    halberd.report(opts.output)


if __name__ == '__main__':
    main(sys.argv[1:])


# vim: ts=4 sw=4 et
