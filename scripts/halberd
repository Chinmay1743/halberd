#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Copyright (C) 2004 Juan M. Bello Rivas <rwx@synnergy.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


"""Command line interface and main driving module.

@var default_scantime: Time to spend probing the target expressed in seconds.
@var default_parallelism: Number of parallel threads to launch for the scan.
@var default_conf_file: Name of the default configuration file for halberd.
@var default_ratio_threshold: Minimum raw-to-analyzed clues ratio to trigger a
clue reanalysis.
"""

__revision__ = '$Id: halberd,v 1.15 2004/02/25 01:30:23 rwx Exp $'


import sys
import socket
import urlparse

import hlbd.version as version
import hlbd.clues.analysis as analysis


default_scantime = 30

default_parallelism = 4

default_conf_file = 'halberd.cfg'

default_ratio_threshold = 0.6


def hostname(url):
    """Obtain hostname part of an URL.

    @param url: A valid URL (must be preceded by scheme://).
    @return: A string containing the hostname corresponding to the URL or None
    in case of failure.
    """
    netloc = urlparse.urlparse(url)[1]
    if netloc == '':
        return None

    return netloc.split(':', 1)[0]

def addresses(host):
    """Returns the list of host's network addresses.
    """
    try:
        name, aliases, addrs = socket.gethostbyname_ex(host)
    except socket.error:
        return None

    return addrs

class Halberd:
    """HTTP load balancer detector.
    """

    def __init__(self, verbose=False):
        self.verbose = verbose

        self.url = None
        self.addr = None

        self.clues = []
        self.analyzed = []

        self.parallelism = default_parallelism
        self.scantime = default_scantime

        self.rpc_servers = None
        self.rpc_serv_addr = None

        self.proxy_serv_addr = None


    def setURL(self, url):
        """Ensures the URL is a valid one.

        @param url: An incomplete (or not) URL. Note that characters are NOT
        escaped. Thus strings like 'http%xx//' will not to be detected.
        """
        if url.startswith('http://') or url.startswith('https://'):
            self.url = url
        else:
            self.url = 'http://' + url

        return self

    def setAddr(self, addr):
        """Sets the target address.
        """
        self.clues = self.analyzed = []
        self.addr = addr

        return self


    def info(self, msg):
        """Display information to the user.
        """
        if self.verbose:
            sys.stdout.write(str(msg))
            sys.stdout.flush()

    def fatal(msg):
        """Fatal error notification.
        """
        sys.stderr.write(str(msg))
        sys.stderr.flush()
        sys.exit(-1)

    fatal = staticmethod(fatal)


    def scan(self):
        import hlbd.scanlib as scanlib

        self.clues += scanlib.scan(self.addr, self.url, self.scantime,
                                  self.parallelism, self.verbose)
    def analyze(self):
        """Analyze clues.
        """
        if len(self.clues) == 0:
            return

        self.analyzed = analysis.analyze(self.clues)
        assert self.analyzed > 0
        ratio = len(self.analyzed) / float(len(self.clues))
        #self.info('clue-to-realserver ratio: %.3f\n' % ratio)
        if ratio >= default_ratio_threshold:
            self.info('clue-to-realserver ratio is high (%.3f)\n' % ratio)
            self.info('reanalyzing clues... ')
            analysis.ignore_changing_fields(self.clues, self.verbose)
            self.analyzed = analysis.analyze(self.clues)
            self.info('done.\n')

    def report(self, outfile):
        """Write a report.
        """
        import hlbd.reportlib

        hlbd.reportlib.report(self.addr, self.analyzed, outfile)


    def server(self):
        """Launch the program as a server.
        """
        import hlbd.rpclib

        hlbd.rpclib.server(self.rpc_serv_addr, self.verbose)

    def client(self):
        """Launch the program as a client.
        """
        def run_thr(addr, port, clues, lock):
            rpclib.client((addr, port), self.addr, self.url, self.scantime,
                          self.parallelism, self.verbose, (clues, lock))

        def normalize_clues(clues, delta):
            for clue in clues:
                clue._local -= delta
                clue._calcDiff()
            return clues

        import threading
        import hlbd.rpclib as rpclib

        assert self.rpc_servers is not None

        threads = []
        results = []
        lock = threading.Lock()

        thread = (threading.Thread(None, self.scan, None, ()))
        thread.start()
        threads.append(thread)

        for rpc_server in self.rpc_servers:
            addr, port = rpc_server.split(':')
            port = int(port)

            self.info('scanning through %s:%d\n' % (addr, port))

            thread = threading.Thread(None, run_thr, None, \
                                            (addr, port, results, lock))
            thread.start()
            threads.append(thread)

        self.info('\n')

        for thread in threads:
            thread.join()

#        for local, remote, clues in results:
        for result in results:
            if len(result) == 3:
                # Clues coming from a distributed scan.
                local, remote, clues = result
                self.clues.extend(normalize_clues(clues, remote - local))
            else:
                # Clues acquired locally.
                self.clues.extend(result)


    def readConf(self, cfgfile):
        """Read configuration file.
        """
        import hlbd.conflib as conflib

        reader = conflib.ConfReader()

        try:
            reader.open(cfgfile)
        except (IOError, conflib.InvalidConfFile):
            self.fatal('couldn\'t open configuration file %s\n' % cfgfile)

        options = reader.parse()
        self.proxy_serv_addr = options.proxy_serv_addr

        self.rpc_serv_addr = options.rpc_serv_addr
        self.rpc_servers = options.rpc_servers

        reader.close()


def make_parser():
    """Sets up the command line option parser.
    """
    import optparse

    parser = optparse.OptionParser(usage='%prog [options] url',
                                   version=version.version.v_gnu)
    parser.add_option('-t', '--time',
                      action='store', type='int', dest='scantime',
                      help='time (in seconds) to spend analyzing the target',
                      metavar='NUM', default=default_scantime)

    parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
                      help='explain what is being done', default=False)

    parser.add_option('-o', '--out', action='store', dest='output',
                      help='write output to the specified file',
                      metavar='FILE', default='')

    parser.add_option('-a', '--addr', action='store', dest='addr',
                      help='specify address to scan',
                      metavar='ADDR', default='')

    parser.add_option('-w', '--write', action='store', dest='savefile',
                      help='saves clues to the specified file',
                      metavar='FILE', default='')
    parser.add_option('-r', '--read', action='store', dest='cluefile',
                      help='loads clues from the specified file',
                      metavar='FILE', default='')

    parser.add_option('-s', '--server', action='store_true', dest='rpc_server',
                      help='run as scan server')
    parser.add_option('-c', '--client', action='store_true', dest='rpc_client',
                      help='run as scan cilent')

    parser.add_option('-p', '--parallelism', action='store', type='int',
                      dest='parallelism',
                      help='specifies the degree of parallelism',
                      metavar='NUM', default=default_parallelism)

    parser.add_option('-f', '--config', action='store', dest='confname',
                      help='use configuration file', metavar='FILE',
                      default=default_conf_file)

    return parser


def main(argv):
    """http load balancer detector's main routine.
    """
    parser = make_parser()

    (opts, args) = parser.parse_args(argv)

    halberd = Halberd(opts.verbose)

    halberd.info('%s\nhttp load balancer detector\n\n' % version.version.v_gnu)

    halberd.readConf(opts.confname)

    if opts.cluefile:
        # Load from file
        halberd.clues = analysis.load_clues(opts.cluefile)
        halberd.analyze()
        halberd.report(opts.output)
        sys.exit(0)
    elif opts.rpc_server:
        halberd.server()
        sys.exit(0)

    # Scan target.
    if len(args) < 1:
        # We need an URL to scan.
        parser.error('incorrect number of arguments')

    halberd.setURL(args[0])
    halberd.scantime = opts.scantime
    halberd.parallelism = opts.parallelism

    # Get network addresses.
    if opts.addr:
        # The user passed a specific address as a parameter.
        addrs = [opts.addr]
    else:
        host = hostname(halberd.url)
        halberd.info('looking up host %s... ' % host)
        addrs = addresses(host)
        if addrs is None:
            Halberd.fatal('unable to resolve %s\n' % host)
        halberd.info('done.\n\n')
        addrs.sort()

    for addr in addrs:
        halberd.setAddr(addr)

        if opts.rpc_client:
            halberd.client()
        else:
            halberd.scan()

        halberd.analyze()

        halberd.report(opts.output)

    if opts.savefile:
        if len(addrs) > 1:
            halberd.info('warning: only the last clues will be stored\n')
        analysis.save_clues(opts.savefile, halberd.clues)


if __name__ == '__main__':
#    import gc
#    gc.set_debug(gc.DEBUG_LEAK)
    main(sys.argv[1:])


# vim: ts=4 sw=4 et
